# -*- coding: utf-8 -*-
"""HTF_Gemini_BackEnd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/119ySib3zuoukjaYATIiw4LycXnel6p-S
"""

# from google.colab import userdata
from config import db
from google import genai
# API_KEY = userdata.get('GeminiAPI')
API_KEY = "AIzaSyC-XukHCg6_neZVFz6fQyejY6F1m-fSM30"
client = genai.Client(api_key=API_KEY)

import time
from flask import jsonify
from google.genai import types

def _rank_condition_vid(file_path1: str, file_path2:str=None, file_path3:str=None, file_path4:str=None):
  file = client.files.upload(file=file_path1)
  print("Please wait as we process your video")
  while file.state.name == "PROCESSING":
    print(".", end="")
    time.sleep(5)
    file = client.files.get(name=file.name)

  if file.state.name == "ERROR" or file.state.name == "FAILED":
    print("Error processing Video")

  system_prompt="""
  You are an expert product condition evaluator whose job is to evaluate a
  returned item's condition and categorize it into one of the following: "Like
  New", "Slightly Used", "Used", "Damaged", "Severely Damaged". Respond with the
  category only and nothing else.
  """

  MODEL_ID = "gemini-2.0-flash"
  response = client.models.generate_content(
    model=f"models/{MODEL_ID}",
    contents=["Please evaluate the condition of this returned product and" +
              "categorize it into one of the 5 specified categories.", file],
    config=types.GenerateContentConfig(system_instruction=system_prompt,),
  )

  condition = response.text

  return {"condition": condition}

_rank_condition_vid("/content/HTF_gemini_test_image.jpg")

from flask import jsonify
from models import Client, Order, Request
def _process_return_helper(order_id, customer_id, file_path1: str, file_path2:str=None,
                           file_path3:str=None, file_path4:str=None):
  condition = _rank_condition_vid(file_path1, file_path2, file_path3, file_path4)
  reason = Order.query.filter_by(order_id=order_id).first().reason

  all_orders = Order.query.filter_by(customer_id=customer_id).all().count()
  num_returns = Order.query.filter_by(customer_id=customer_id, returned="1").all().count()
  return_rate = num_returns/all_orders

  price = Order.query.filter_by(order_id=order_id).first().product_price

  return_order = None
  json = None

  # need to check if return is within return period outlined by client policy

  return_date = Order.query.filter_by(order_id=order_id).first().order_date

  if (return_date + timedelta(90)) < datetime.today():
    return_order = Request(order_id, customer_id, condition, datetime.today(),
                           "Denied", datetime.today() + timedelta(7), reason)
    json = jsonify({"Status": "Denied", "Reason": "Return Period has passed"})

    db.session.add(return_order)
    db.session.commit()
    return json

  if return_rate > 0.7:
    # s="""Return Denied: You have returned too many items recently. To prevent
    # excessive returns, we will temporarily deny return requests.
    # """
    return_order = Request(order_id, customer_id, condition, datetime.today(),
                           "Denied", datetime.today() + timedelta(7), reason)
    json = jsonify({"Status": "Denied", "Reason": "Return Rate"})

    db.session.add(return_order)
    db.session.commit()
    return json


  if condition == "Like New" or condition == "Slightly Used":


    if reason == "Wrong Size":
      return_order = Request(order_id, customer_id, condition, "Exchange", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Approved", "Refund": price}), 200

    elif reason in ["Wrong Item", "Item not as described",
                    "Not Satisfied", "Dont Want Item Anymore"]:

      return_order = Request(order_id, customer_id, condition, "Restock", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)
      json = jsonify({"Status": "Approved", "Refund": price}), 200

    # need to calculate
    elif reason in ["Defective or Damaged", "Missing Parts or Accessories"]:

      return_order = Request(order_id, customer_id, condition, "Refurbish", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)

  elif condition == "Used":


    if reason == "Wrong Size":

      return_order = Request(order_id, customer_id, condition, "Exchange", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Approved", "Refund": price*0.7}), 200

    elif reason in ["Wrong Item", "Item not as described",
                    "Not Satisfied", "Dont Want Item Anymore"]:

      return_order = Request(order_id, customer_id, condition, "Refurbish", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Approved", "Refund": price*0.8}), 200

    elif reason in ["Defective or Damaged", "Missing Parts or Accessories"]:

      return_order = Request(order_id, customer_id, condition, datetime.today(),
                             "Denied", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Denied", "Reason": "Damaged by Customer"}), 200

  elif condition == "Damaged" or condition == "Severely Damaged":

    # need to check if product was not damaged by user

    if reason == "Defective or Damaged":
      return_order = Request(order_id, customer_id, condition, "Recycle", datetime.today(),
                             "Approved", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Approved", "Refund": price}), 200
    else:
      return_order = Request(order_id, customer_id, condition, datetime.today(),
                             "Denied", datetime.today() + timedelta(7), reason)

      json = jsonify({"Status": "Denied", "Reason": "Damaged by Customer"}), 200

  db.session.add(return_order)
  db.session.commit()

  return json

from datetime import datetime, timedelta


